// <auto-generated>
// Generated by ECSReact ISystem Bridge Generator
// Source: AddCharacterMiddleware
// Type: IMiddleware
// Generated at: 2025-10-08 00:07:59
// Do not modify this file directly - changes will be lost on regeneration
// </auto-generated>

using Unity.Entities;
using Unity.Burst;
using Unity.Collections;
using ECSReact.Core;
using ECSReact.Samples.BattleSystem;

namespace ECSReact.Samples.BattleSystem
{
  /// <summary>
  /// Generated ISystem implementation for AddCharacterMiddleware.
  /// Type: IMiddleware
  /// Action: AddCharacterAction
  /// Can filter actions
  /// </summary>
  [UpdateInGroup(typeof(MiddlewareSystemGroup))]
  public partial struct AddCharacterMiddleware_System : ISystem
  {
    private AddCharacterMiddleware logic;
    private EntityQuery actionQuery;

    // ECB writer for Burst-compatible action dispatching
    private EntityCommandBuffer.ParallelWriter ecbWriter;

    public void OnCreate(ref SystemState state)
    {
      logic = new AddCharacterMiddleware();

      // Use EntityQueryBuilder for Burst compatibility
      var queryBuilder = new EntityQueryBuilder(Allocator.Temp)
        .WithAll<AddCharacterAction, ActionTag>();
      actionQuery = state.GetEntityQuery(queryBuilder);
      queryBuilder.Dispose();

      state.RequireForUpdate(actionQuery);
      state.RequireForUpdate<AddCharacterAction>();
    }

    // NOT Burst compiled - allows main-thread ECB fetch
    public void OnUpdate(ref SystemState state)
    {
      // Pre-fetch ECB writer on main thread (MUST happen before Burst context)
      ecbWriter = ECSActionDispatcher.GetJobCommandBuffer(state.World);

      // Call Burst-compiled middleware processing
      ProcessMiddleware(ref state);

      // Register job handle for proper synchronization
      ECSActionDispatcher.RegisterJobHandle(state.Dependency, state.World);
    }

    private void ProcessMiddleware(ref SystemState state)
    {
      // ECB for filtering actions (destroy entity if filtered)
      var ecb = new EntityCommandBuffer(Allocator.TempJob);

      // Process all actions sequentially - can filter
      int sortKey = 0;
      foreach (var (action, entity) in SystemAPI.Query<RefRW<AddCharacterAction>>()
          .WithAll<ActionTag>().WithEntityAccess())
      {
        // Call user's middleware with dispatcher and sortKey
        bool shouldContinue = logic.Process(
          ref action.ValueRW,
          ref state,
          ecbWriter,      // Dispatcher for action dispatching
          sortKey         // Sort key for deterministic ordering
        );

        if (!shouldContinue)
        {
          // Middleware filtered this action - destroy it
          ecb.DestroyEntity(entity);
        }

        sortKey++;
      }

      ecb.Playback(state.EntityManager);
      ecb.Dispose();
    }

    public void OnDestroy(ref SystemState state) { }

  }
}
