// <auto-generated>
// Generated by ECSReact ISystem Bridge Generator
// Source: NextTurnMiddleware
// Type: IMiddleware
// Generated at: 2025-10-11 00:57:38
// Do not modify this file directly - changes will be lost on regeneration
// </auto-generated>

using Unity.Entities;
using Unity.Burst;
using Unity.Collections;
using ECSReact.Core;
using ECSReact.Samples.BattleSystem;

namespace ECSReact.Samples.BattleSystem
{
  /// <summary>
  /// Generated ISystem implementation for NextTurnMiddleware.
  /// Type: IMiddleware
  /// Action: ReadyForNextTurn
  /// Can filter actions
  /// </summary>
  [UpdateInGroup(typeof(MiddlewareSystemGroup))]
  [BurstCompile]
  public partial struct NextTurnMiddleware_System : ISystem
  {
    private NextTurnMiddleware logic;
    private EntityQuery actionQuery;

    // ECB writer for Burst-compatible action dispatching
    private EntityCommandBuffer.ParallelWriter ecbWriter;
    private ComponentLookup<ReadyForNextTurn> actionLookup;

    [BurstCompile]
    public void OnCreate(ref SystemState state)
    {
      logic = new NextTurnMiddleware();

      // Use EntityQueryBuilder for Burst compatibility
      var queryBuilder = new EntityQueryBuilder(Allocator.Temp)
        .WithAll<ReadyForNextTurn, ActionTag>();
      actionQuery = state.GetEntityQuery(queryBuilder);
      queryBuilder.Dispose();

      actionLookup = state.GetComponentLookup<ReadyForNextTurn>(isReadOnly: false);
      state.RequireForUpdate(actionQuery);
      state.RequireForUpdate<ReadyForNextTurn>();
    }

    public void OnUpdate(ref SystemState state)
    {
      // Pre-fetch ECB writer on main thread
      ecbWriter = ECSActionDispatcher.GetJobCommandBuffer(state.World);

      // Update ComponentLookup to latest data
      actionLookup.Update(ref state);

      // Call Burst-compiled middleware processing
      ProcessMiddleware(ref state, actionLookup);

      // Register job handle for proper synchronization
      ECSActionDispatcher.RegisterJobHandle(state.Dependency, state.World);
    }

    [BurstCompile]
    private void ProcessMiddleware(
      ref SystemState state,
      ComponentLookup<ReadyForNextTurn> actionLookup)
    {
      // ECB for filtering actions (destroy entity if filtered)
      var ecb = new EntityCommandBuffer(Allocator.TempJob);

      // Process all actions sequentially - uses cached query
      var entities = actionQuery.ToEntityArray(Allocator.Temp);
      int sortKey = 0;
      
      // Check if action is zero-sized (no fields)
      var type = new ComponentType(typeof(ReadyForNextTurn));
      bool isZeroSized = type.IsZeroSized;
      
      foreach (var entity in entities)
      {
        bool shouldContinue;
        
        if (isZeroSized)
        {
          // Zero-sized components: use default value
          var action = default(ReadyForNextTurn);
          shouldContinue = logic.Process(
            ref action,
            ref state,
            ecbWriter,
            sortKey
          );
        }
        else
        {
          // Normal components: use ComponentLookup
          var action =  actionLookup.GetRefRW(entity);
          shouldContinue = logic.Process(
            ref action.ValueRW,
            ref state,
            ecbWriter,
            sortKey
          );
        }

        if (!shouldContinue)
        {
          // Middleware filtered this action - destroy it
          ecb.DestroyEntity(entity);
        }

        sortKey++;
      }
      
      entities.Dispose();
      ecb.Playback(state.EntityManager);
      ecb.Dispose();
    }

    public void OnDestroy(ref SystemState state) { }

  }
}
