// <auto-generated>
// Generated by ECSReact ISystem Bridge Generator
// Source: IntReducerNamespace1
// Type: IReducer
// Generated at: 2025-11-11 00:18:52
// Do not modify this file directly - changes will be lost on regeneration
// </auto-generated>

using Unity.Entities;
using Unity.Burst;
using Unity.Collections;
using ECSReact.Core;
using ECSReact.Samples.SimpleSetup.Namespace1.Reducers;

namespace ECSReact.Samples.SimpleSetup.Namespace1.Reducers
{
  /// <summary>
  /// Generated ISystem implementation for IntReducerNamespace1.
  /// State: ECSReact.Samples.SimpleSetup.Namespace1.State.StateNamespace1
  /// Action: ECSReact.Samples.SimpleSetup.Namespace1.Actions.ActionIntNamespace1
  /// </summary>
  [UpdateInGroup(typeof(ReducerSystemGroup))]
  [BurstCompile]
  public partial struct IntReducerNamespace1_System : ISystem
  {
    private IntReducerNamespace1 logic;
    private EntityQuery actionQuery;
    private ComponentLookup<ECSReact.Samples.SimpleSetup.Namespace1.Actions.ActionIntNamespace1> actionLookup;

    [BurstCompile]
    public void OnCreate(ref SystemState state)
    {
      logic = new IntReducerNamespace1();

      // Use EntityQueryBuilder for Burst compatibility
      var queryBuilder = new EntityQueryBuilder(Allocator.Temp)
        .WithAll<ECSReact.Samples.SimpleSetup.Namespace1.Actions.ActionIntNamespace1, ActionTag>();
      actionQuery = state.GetEntityQuery(queryBuilder);
      queryBuilder.Dispose();

      // Create ComponentLookup once for reuse
      actionLookup = state.GetComponentLookup<ECSReact.Samples.SimpleSetup.Namespace1.Actions.ActionIntNamespace1>(isReadOnly: true);

      state.RequireForUpdate<ECSReact.Samples.SimpleSetup.Namespace1.State.StateNamespace1>();
      state.RequireForUpdate(actionQuery);
    }

    public void OnUpdate(ref SystemState state)
    {
      var gameState = SystemAPI.GetSingletonRW<ECSReact.Samples.SimpleSetup.Namespace1.State.StateNamespace1>();

      // Update ComponentLookup to latest data
      actionLookup.Update(ref state);
      
      // Call Burst-compiled processing
      ProcessActions(ref state, gameState, actionLookup);
    }

    [BurstCompile]
    private void ProcessActions(
      ref SystemState state,
      RefRW<ECSReact.Samples.SimpleSetup.Namespace1.State.StateNamespace1> gameState,
      ComponentLookup<ECSReact.Samples.SimpleSetup.Namespace1.Actions.ActionIntNamespace1> actionLookup)
    {
      // Process all actions sequentially - uses cached query
      var entities = actionQuery.ToEntityArray(Allocator.Temp);

      // ✅ Check once per frame if component is zero-sized
      var type = new ComponentType(typeof(ECSReact.Samples.SimpleSetup.Namespace1.Actions.ActionIntNamespace1));
      bool isZeroSized = type.IsZeroSized;

      foreach (var entity in entities)
      {
        if (isZeroSized) {
          // ✅ Zero-sized: use default value
          var action = default(ECSReact.Samples.SimpleSetup.Namespace1.Actions.ActionIntNamespace1);
          logic.Execute(ref gameState.ValueRW, in action, ref state);
        } else {
          var action =  actionLookup.GetRefRO(entity);
          logic.Execute(ref gameState.ValueRW, in action.ValueRO, ref state);
        }
      }
      
      entities.Dispose();
    }

  }
}
